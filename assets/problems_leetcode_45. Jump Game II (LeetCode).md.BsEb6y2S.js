import{_ as i,c as a,o as n,ae as h}from"./chunks/framework.ClVAdkRN.js";const g=JSON.parse('{"title":"45. Jump Game II (LeetCode)","description":"","frontmatter":{},"headers":[],"relativePath":"problems/leetcode/45. Jump Game II (LeetCode).md","filePath":"problems/leetcode/45. Jump Game II (LeetCode).md"}'),t={name:"problems/leetcode/45. Jump Game II (LeetCode).md"};function l(e,s,k,p,d,r){return n(),a("div",null,s[0]||(s[0]=[h(`<h1 id="_45-jump-game-ii-leetcode" tabindex="-1">45. Jump Game II (LeetCode) <a class="header-anchor" href="#_45-jump-game-ii-leetcode" aria-label="Permalink to &quot;45. Jump Game II (LeetCode)&quot;">​</a></h1><p>🔗 문제 링크 → <a href="https://leetcode.com/problems/jump-game-ii" target="_blank" rel="noreferrer">LeetCode 45. Jump Game II</a></p><h2 id="🧩-문제-설명" tabindex="-1">🧩 문제 설명 <a class="header-anchor" href="#🧩-문제-설명" aria-label="Permalink to &quot;🧩 문제 설명&quot;">​</a></h2><p>정수 배열 <code>nums</code>가 주어집니다. 각 요소 <code>nums[i]</code>는 현재 인덱스 <code>i</code>에서 최대로 점프할 수 있는 거리입니다. 배열의 <strong>첫 번째 인덱스</strong>에서 시작해 <strong>마지막 인덱스</strong>에 도달하기 위해 <strong>가장 적은 점프 횟수</strong>를 구하세요.</p><ul><li>항상 도달할 수 있는 입력만 주어집니다.</li></ul><h3 id="예시" tabindex="-1">예시 <a class="header-anchor" href="#예시" aria-label="Permalink to &quot;예시&quot;">​</a></h3><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: nums </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Output</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 첫 번째 위치에서 2칸 점프 → 인덱스 1 (값 3)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 인덱스 1에서 3칸 점프 → 인덱스 4 (도착)</span></span></code></pre></div><h2 id="💡-아이디어" tabindex="-1">💡 아이디어 <a class="header-anchor" href="#💡-아이디어" aria-label="Permalink to &quot;💡 아이디어&quot;">​</a></h2><p>이 문제는 <strong>최소 점프 횟수</strong>를 구하는 것이므로, <strong>DP (Dynamic Programming)</strong> 혹은 <strong>Greedy</strong> 방식으로 접근할 수 있습니다.</p><h3 id="✅-방법-1-bottom-up-dp" tabindex="-1">✅ 방법 1: Bottom-up DP <a class="header-anchor" href="#✅-방법-1-bottom-up-dp" aria-label="Permalink to &quot;✅ 방법 1: Bottom-up DP&quot;">​</a></h3><ul><li><code>dp[i]</code>를 인덱스 <code>i</code>에서 끝까지 가는 최소 점프 횟수라고 정의합니다.</li><li>배열의 끝에서부터 거꾸로 계산하면서, <code>i</code>에서 도달 가능한 다음 위치들의 최소값을 참조하여 <code>dp[i]</code>를 갱신합니다.</li><li>마지막 인덱스는 도달한 상태이므로 <code>dp[n-1] = 0</code>으로 초기화합니다.</li></ul><h3 id="✅-방법-2-greedy" tabindex="-1">✅ 방법 2: Greedy <a class="header-anchor" href="#✅-방법-2-greedy" aria-label="Permalink to &quot;✅ 방법 2: Greedy&quot;">​</a></h3><ul><li>현재 탐색 구간 내에서 도달 가능한 <strong>가장 먼 위치</strong>를 계산하고, 그 범위를 벗어나면 점프를 추가합니다.</li><li>항상 가장 멀리 갈 수 있는 위치를 탐색하기 때문에 <strong>O(n)</strong> 시간에 해결할 수 있습니다.</li></ul><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> jump</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">nums</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[])</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> jumps </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> currentEnd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> farthest </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    farthest </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">max</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(farthest, i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums[i])</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> currentEnd) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      jumps</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      currentEnd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> farthest</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> jumps</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="✅-typescript-코드-dp-방식" tabindex="-1">✅ TypeScript 코드 (DP 방식) <a class="header-anchor" href="#✅-typescript-코드-dp-방식" aria-label="Permalink to &quot;✅ TypeScript 코드 (DP 방식)&quot;">​</a></h2><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> jump</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">nums</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[])</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> dp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Number.MAX_SAFE_INTEGER)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  dp[n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> maxJump</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums[i]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> maxJump </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      dp[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">min</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dp[i], dp[i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="🛠️-코드-동작-원리" tabindex="-1">🛠️ 코드 동작 원리 <a class="header-anchor" href="#🛠️-코드-동작-원리" aria-label="Permalink to &quot;🛠️ 코드 동작 원리&quot;">​</a></h2><h3 id="dp-방식" tabindex="-1">DP 방식 <a class="header-anchor" href="#dp-방식" aria-label="Permalink to &quot;DP 방식&quot;">​</a></h3><ol><li><code>dp[n-1] = 0</code>으로 마지막 위치는 점프가 필요 없음을 설정</li><li><code>i</code>를 배열의 끝에서부터 시작해 0까지 이동</li><li>각 위치에서 점프 가능한 거리(<code>nums[i]</code>)만큼 다음 위치들을 탐색</li><li>도달 가능한 다음 위치들의 <code>dp</code>값 중 최소에 +1 하여 <code>dp[i]</code> 갱신</li><li><code>dp[0]</code>에 최소 점프 횟수가 저장되어 반환</li></ol><h3 id="greedy-방식" tabindex="-1">Greedy 방식 <a class="header-anchor" href="#greedy-방식" aria-label="Permalink to &quot;Greedy 방식&quot;">​</a></h3><ol><li><code>i</code>를 0부터 끝까지 순회하면서 <code>i + nums[i]</code>로 가장 멀리 갈 수 있는 지점(<code>farthest</code>) 갱신</li><li>현재 탐색 범위가 끝나는 지점(<code>currentEnd</code>)에 도달하면 점프 수 증가 후, 탐색 범위를 <code>farthest</code>로 갱신</li><li>마지막 인덱스를 포함할 때까지 반복</li></ol><h2 id="📊-시간-복잡도-공간-복잡도-분석" tabindex="-1">📊 시간 복잡도 &amp; 공간 복잡도 분석 <a class="header-anchor" href="#📊-시간-복잡도-공간-복잡도-분석" aria-label="Permalink to &quot;📊 시간 복잡도 &amp; 공간 복잡도 분석&quot;">​</a></h2><table tabindex="0"><thead><tr><th>방식</th><th>시간 복잡도</th><th>공간 복잡도</th></tr></thead><tbody><tr><td>DP</td><td>O(n^2)</td><td>O(n)</td></tr><tr><td>Greedy</td><td>O(n)</td><td>O(1)</td></tr></tbody></table><h2 id="🔄-다른-풀이-방법과-비교" tabindex="-1">🔄 다른 풀이 방법과 비교 <a class="header-anchor" href="#🔄-다른-풀이-방법과-비교" aria-label="Permalink to &quot;🔄 다른 풀이 방법과 비교&quot;">​</a></h2><ul><li><strong>Greedy 방법</strong>: 매번 도달할 수 있는 최대 범위를 업데이트하면서 점프 횟수를 세는 방식. <strong>시간 복잡도 O(n)</strong> 으로 가장 효율적입니다.</li><li><strong>DP 방법</strong>: 직관적이며 구조화된 접근이지만, 비효율적인 중복 계산이 발생할 수 있어 <strong>속도 면에서 불리</strong>합니다.</li></ul><h2 id="📝-핵심-내용-요약" tabindex="-1">📝 핵심 내용 요약 <a class="header-anchor" href="#📝-핵심-내용-요약" aria-label="Permalink to &quot;📝 핵심 내용 요약&quot;">​</a></h2><ul><li>문제 유형: 최소 횟수로 도달하는 경로 → 최적화 문제 → DP 또는 Greedy</li><li>DP 방식: <code>dp[i]</code> = i에서 끝까지 가는 최소 점프 수</li><li>Greedy 방식: 매 탐색 구간마다 가장 멀리 도달 가능한 위치를 선택</li><li>효율성 면에서는 <strong>Greedy 방식이 최적 (O(n))</strong></li></ul>`,27)]))}const o=i(t,[["render",l]]);export{g as __pageData,o as default};
