import{_ as i,c as a,o as t,ae as n}from"./chunks/framework.ClVAdkRN.js";const E=JSON.parse('{"title":"Two Sum (LeetCode 1)","description":"","frontmatter":{},"headers":[],"relativePath":"problems/leetcode/p1.md","filePath":"problems/leetcode/p1.md"}'),l={name:"problems/leetcode/p1.md"};function h(e,s,p,k,r,d){return t(),a("div",null,s[0]||(s[0]=[n(`<h1 id="two-sum-leetcode-1" tabindex="-1">Two Sum (LeetCode 1) <a class="header-anchor" href="#two-sum-leetcode-1" aria-label="Permalink to &quot;Two Sum (LeetCode 1)&quot;">​</a></h1><p>🔗 문제 링크 → <a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noreferrer">LeetCode 1. Two Sum</a></p><h2 id="문제-설명" tabindex="-1">문제 설명 <a class="header-anchor" href="#문제-설명" aria-label="Permalink to &quot;문제 설명&quot;">​</a></h2><p>주어진 정수 배열 <code>nums</code>와 정수 <code>target</code>이 있습니다. 배열 내에서 서로 다른 두 원소의 합이 <code>target</code>이 되는 인덱스를 찾아야 합니다. 같은 원소를 두 번 사용할 수 없으며, 정답은 반드시 하나 존재한다고 가정합니다.</p><p><strong>입력:</strong></p><ul><li>정수 배열 <code>nums</code> (길이 n, 2 &lt;= n &lt;= 10⁴)</li><li>정수 <code>target</code></li></ul><p><strong>출력:</strong></p><ul><li>두 원소의 인덱스를 담은 배열 (순서 무관)</li></ul><h2 id="💡-문제-해결-전략" tabindex="-1">💡 문제 해결 전략 <a class="header-anchor" href="#💡-문제-해결-전략" aria-label="Permalink to &quot;💡 문제 해결 전략&quot;">​</a></h2><ol><li><strong>브루트포스 접근:</strong> 모든 쌍을 확인해 <code>target</code>과 같은지 비교 (O(n²))</li><li><strong>해시맵을 활용한 최적화:</strong> 한 번의 순회로 현재 원소의 보수를 해시맵에 저장하며, 현재 원소가 해시맵에 있는지 확인 (O(n))</li></ol><p>효율성을 위해 <strong>해시맵을 활용한 방법</strong>을 선택합니다.</p><h2 id="typescript-풀이" tabindex="-1">TypeScript 풀이 <a class="header-anchor" href="#typescript-풀이" aria-label="Permalink to &quot;TypeScript 풀이&quot;">​</a></h2><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> twoSum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">nums</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[], </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">target</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> map</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> complement</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums[i]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (map.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">has</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(complement)) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [map.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(complement)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, i]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    map.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nums[i], i)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;No solution found&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="🛠️-코드-동작-원리" tabindex="-1">🛠️ 코드 동작 원리 <a class="header-anchor" href="#🛠️-코드-동작-원리" aria-label="Permalink to &quot;🛠️ 코드 동작 원리&quot;">​</a></h2><ol><li><strong>빈 해시맵 생성:</strong> 숫자 값과 그에 해당하는 인덱스를 저장합니다.</li><li><strong>배열 순회:</strong><ul><li>현재 숫자의 보수(<code>target - 현재 숫자</code>)가 해시맵에 있는지 확인</li><li>있다면, 보수의 인덱스와 현재 인덱스를 반환</li><li>없다면, 현재 숫자와 인덱스를 해시맵에 저장</li></ul></li><li><strong>반환:</strong> 정답은 반드시 존재하므로, 정상적으로 인덱스 쌍 반환</li></ol><h2 id="📊-시간-복잡도-공간-복잡도-분석" tabindex="-1">📊 시간 복잡도 &amp; 공간 복잡도 분석 <a class="header-anchor" href="#📊-시간-복잡도-공간-복잡도-분석" aria-label="Permalink to &quot;📊 시간 복잡도 &amp; 공간 복잡도 분석&quot;">​</a></h2><table tabindex="0"><thead><tr><th>구분</th><th>복잡도</th></tr></thead><tbody><tr><td>시간 복잡도</td><td>O(n)</td></tr><tr><td>공간 복잡도</td><td>O(n)</td></tr></tbody></table><ul><li><strong>시간 복잡도:</strong> 배열을 한 번만 순회하며, 해시맵의 조회 및 삽입은 O(1)</li><li><strong>공간 복잡도:</strong> 최악의 경우 해시맵에 n개의 원소가 저장됨</li></ul><h2 id="🔀-다른-풀이-방법과-효율성-비교" tabindex="-1">🔀 다른 풀이 방법과 효율성 비교 <a class="header-anchor" href="#🔀-다른-풀이-방법과-효율성-비교" aria-label="Permalink to &quot;🔀 다른 풀이 방법과 효율성 비교&quot;">​</a></h2><table tabindex="0"><thead><tr><th>방법</th><th>시간 복잡도</th><th>공간 복잡도</th><th>특징</th></tr></thead><tbody><tr><td>브루트포스 (이중 루프)</td><td>O(n²)</td><td>O(1)</td><td>간단하지만 비효율적</td></tr><tr><td>정렬 후 투 포인터</td><td>O(n log n)</td><td>O(1)</td><td>인덱스가 필요한 경우 부적합 (인덱스 손실)</td></tr><tr><td>해시맵 사용 (현재 방법)</td><td>O(n)</td><td>O(n)</td><td>최적, 한 번의 순회로 해결 가능</td></tr></tbody></table><h2 id="📝-요점-정리" tabindex="-1">📝 요점 정리 <a class="header-anchor" href="#📝-요점-정리" aria-label="Permalink to &quot;📝 요점 정리&quot;">​</a></h2><ul><li>해시맵을 활용하면 O(n) 시간 복잡도로 문제를 효율적으로 해결 가능</li><li>인덱스를 유지하면서 빠른 조회가 필요한 문제에 적합</li><li>다른 방법에 비해 직관적이고 구현이 간단하며 가장 효율적</li></ul>`,22)]))}const g=i(l,[["render",h]]);export{E as __pageData,g as default};
