import{_ as a,c as t,o as r,ae as i}from"./chunks/framework.ClVAdkRN.js";const p=JSON.parse('{"title":"DFS & Backtracking","description":"","frontmatter":{},"headers":[],"relativePath":"theory/algorithm/dfs/index.md","filePath":"theory/algorithm/dfs/index.md"}'),o={name:"theory/algorithm/dfs/index.md"};function l(s,e,c,n,d,h){return r(),t("div",null,e[0]||(e[0]=[i('<h1 id="dfs-backtracking" tabindex="-1">DFS &amp; Backtracking <a class="header-anchor" href="#dfs-backtracking" aria-label="Permalink to &quot;DFS &amp; Backtracking&quot;">​</a></h1><p><img src="https://swexpertacademy.com/main/images/sw_sub/img_visualcodelist_13.png" alt="https://swexpertacademy.com/main/images/sw_sub/img_visualcodelist_13.png"></p><p><img src="https://swexpertacademy.com/main/images/sw_sub/img_visualcodelist_01.png" alt="https://swexpertacademy.com/main/images/sw_sub/img_visualcodelist_01.png"></p><h2 id="깊이-우선-탐색-depth-first-search" tabindex="-1">깊이 우선 탐색(Depth First Search) <a class="header-anchor" href="#깊이-우선-탐색-depth-first-search" aria-label="Permalink to &quot;깊이 우선 탐색(Depth First Search)&quot;">​</a></h2><ul><li><code>재귀함수</code>를 이용</li><li><code>조건에 도달하면 함수를 리턴</code>하면서 스택에 쌓인 함수를 수행해낸다.</li><li><strong>가능 여부/최적의 경로를 탐색</strong>에서 사용</li></ul><h3 id="효율성-높이는-방법" tabindex="-1">효율성 높이는 방법 <a class="header-anchor" href="#효율성-높이는-방법" aria-label="Permalink to &quot;효율성 높이는 방법&quot;">​</a></h3><ul><li>방문체크를 이용한 방법 <ul><li>경로를 탐색 후 방문 체크를 풀어주는 방법</li><li>경로를 탐색할때 방문 체크를 해주어 중복 방문을 막는 방법</li></ul></li><li><strong>백트래킹</strong>을 이용한 방법</li><li><code>DP</code>를 이용하여 최소 경로를 찾는 방법이 존재</li></ul><h3 id="주의" tabindex="-1">주의 <a class="header-anchor" href="#주의" aria-label="Permalink to &quot;주의&quot;">​</a></h3><p>조건을 적절하게 넣지 않으면 매우 많은 depth가 생기게되고 이것은 Stack overflow가 발생할 수 있다.</p><h2 id="백트래킹-backtracking" tabindex="-1">백트래킹(Backtracking) <a class="header-anchor" href="#백트래킹-backtracking" aria-label="Permalink to &quot;백트래킹(Backtracking)&quot;">​</a></h2><p>해를 찾아가는 도중, 현재 경로가 해가 되지 않거나 될 수 없다면 더이상 가지않고 돌아가는 것을 말합니다.</p><p>이 방법은 알고리즘 문제를 풀때 코드를 반복적으로 실행되는 횟수를 줄이므로써 시간복잡도를 줄일 수 있는 효율적인 방법입니다.</p><p>일반적으로 <strong>가지치기</strong>라고 불리며, 불필요한 경우의 수를 줄이고 올바른 방향으로 갈 수 있게 만드는 방법을 말합니다.<br> 보통 백트래킹은 DFS와 함께 사용되고, 가지치기를 얼마나 잘하느냐에 따라서 효율성이 결정되기도함으로 문제를 풀어나갈때 시간 부족현상이 발생한다면 이 부분을 고려해서 다시 구현해보는것을 추천드립니다.</p><h3 id="대표-문제" tabindex="-1">대표 문제 <a class="header-anchor" href="#대표-문제" aria-label="Permalink to &quot;대표 문제&quot;">​</a></h3><ul><li>leetcode : <a href="https://leetcode.com/problems/word-search/" target="_blank" rel="noreferrer">79. Word Search</a> :: <a href="https://github.com/253eosam/Algorithm/blob/master/leetcode/p79.md" target="_blank" rel="noreferrer">풀이</a></li><li>leetcode : <a href="https://leetcode.com/problems/combination-sum/" target="_blank" rel="noreferrer">39. Combination Sum</a> :: <a href="https://github.com/253eosam/Algorithm/blob/master/leetcode/p39.md" target="_blank" rel="noreferrer">풀이</a></li></ul>',15)]))}const g=a(o,[["render",l]]);export{p as __pageData,g as default};
