import{_ as i,c as a,o as h,ae as n}from"./chunks/framework.Dh1jimFm.js";const E=JSON.parse('{"title":"정렬된 배열에서 중복 제거 II (LeetCode P80)","description":"","frontmatter":{},"headers":[],"relativePath":"problems/leetcode/p80.md","filePath":"problems/leetcode/p80.md"}'),e={name:"problems/leetcode/p80.md"};function t(l,s,k,p,d,r){return h(),a("div",null,s[0]||(s[0]=[n(`<h1 id="정렬된-배열에서-중복-제거-ii-leetcode-p80" tabindex="-1">정렬된 배열에서 중복 제거 II (LeetCode P80) <a class="header-anchor" href="#정렬된-배열에서-중복-제거-ii-leetcode-p80" aria-label="Permalink to &quot;정렬된 배열에서 중복 제거 II (LeetCode P80)&quot;">​</a></h1><h2 id="문제-설명" tabindex="-1">문제 설명 <a class="header-anchor" href="#문제-설명" aria-label="Permalink to &quot;문제 설명&quot;">​</a></h2><p>정수 배열 <code>nums</code>가 오름차순으로 정렬되어 있습니다. 배열에서 일부 중복을 제거하여 각 고유 요소가 최대 두 번까지 등장할 수 있도록 해야 합니다. 단, 요소의 상대적인 순서는 유지해야 합니다.</p><p>배열의 길이를 변경할 수 없는 경우가 있으므로, 결과는 배열 <code>nums</code>의 처음 <code>k</code>개의 요소에 저장되어야 합니다. 즉, 중복을 제거한 후 <code>k</code>개의 요소가 <code>nums</code>의 처음 <code>k</code> 위치에 있도록 해야 합니다. 이후의 요소는 상관없습니다.</p><p>최종 배열의 길이 <code>k</code>를 반환하세요.</p><h3 id="예제" tabindex="-1">예제 <a class="header-anchor" href="#예제" aria-label="Permalink to &quot;예제&quot;">​</a></h3><h4 id="입력" tabindex="-1">입력: <a class="header-anchor" href="#입력" aria-label="Permalink to &quot;입력:&quot;">​</a></h4><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">nums </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><h4 id="출력" tabindex="-1">출력: <a class="header-anchor" href="#출력" aria-label="Permalink to &quot;출력:&quot;">​</a></h4><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (nums </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, _])</span></span></code></pre></div><h2 id="해결-방법" tabindex="-1">해결 방법 <a class="header-anchor" href="#해결-방법" aria-label="Permalink to &quot;해결 방법&quot;">​</a></h2><p>배열을 순회하면서 중복되지 않은 요소를 저장할 위치를 나타내는 포인터(<code>insertPos</code>)를 유지합니다. 또한, 현재 숫자가 이미 한 번 중복되었는지를 추적하기 위해 불리언 변수(<code>hasDuplicate</code>)를 사용합니다.</p><h3 id="풀이-과정" tabindex="-1">풀이 과정: <a class="header-anchor" href="#풀이-과정" aria-label="Permalink to &quot;풀이 과정:&quot;">​</a></h3><ol><li>두 번째 요소(<code>cur = 1</code>)부터 반복을 시작합니다.</li><li>현재 숫자가 <code>nums[insertPos]</code>와 같고 이미 한 번 중복되었다면 건너뜁니다.</li><li>그렇지 않다면 <code>nums[++insertPos]</code>에 <code>nums[cur]</code>을 저장합니다.</li><li>최종적으로 <code>insertPos + 1</code>을 반환하여 새로운 배열의 길이를 반환합니다.</li></ol><h3 id="코드-구현" tabindex="-1">코드 구현 <a class="header-anchor" href="#코드-구현" aria-label="Permalink to &quot;코드 구현&quot;">​</a></h3><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> removeDuplicates</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">nums</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[])</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> insertPos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> hasDuplicate </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cur </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; cur </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; cur</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (nums[cur] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums[insertPos] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> hasDuplicate) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">continue</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    hasDuplicate </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums[cur] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums[insertPos]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    nums[</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">insertPos] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums[cur]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> insertPos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="시간-및-공간-복잡도-분석" tabindex="-1">시간 및 공간 복잡도 분석 <a class="header-anchor" href="#시간-및-공간-복잡도-분석" aria-label="Permalink to &quot;시간 및 공간 복잡도 분석&quot;">​</a></h2><ul><li><strong>시간 복잡도</strong>: <code>O(n)</code>, 배열을 한 번 순회하기 때문에 선형 시간 복잡도를 가집니다.</li><li><strong>공간 복잡도</strong>: <code>O(1)</code>, 추가적인 저장 공간 없이 배열을 직접 수정하여 해결합니다.</li></ul><h2 id="고려된-엣지-케이스" tabindex="-1">고려된 엣지 케이스 <a class="header-anchor" href="#고려된-엣지-케이스" aria-label="Permalink to &quot;고려된 엣지 케이스&quot;">​</a></h2><ul><li>중복이 없는 배열: <code>[1,2,3,4,5]</code></li><li>모든 요소가 동일한 배열: <code>[2,2,2,2,2]</code></li><li>모든 숫자가 정확히 두 번씩 등장하는 배열: <code>[1,1,2,2,3,3]</code></li><li>길이가 1인 배열: <code>[1]</code></li></ul><h2 id="요약" tabindex="-1">요약 <a class="header-anchor" href="#요약" aria-label="Permalink to &quot;요약&quot;">​</a></h2><p>이 접근 방식은 최소한의 추가 로직으로 중복을 제거하면서도 순서를 유지하는 데 효과적입니다. 시간 및 공간 복잡도 면에서도 최적화된 솔루션입니다.</p>`,22)]))}const c=i(e,[["render",t]]);export{E as __pageData,c as default};
