import{_ as i,c as a,o as t,ae as l}from"./chunks/framework.ClVAdkRN.js";const E=JSON.parse('{"title":"1. Two Sum (LeetCode)","description":"","frontmatter":{},"headers":[],"relativePath":"problems/leetcode/p1.md","filePath":"problems/leetcode/p1.md"}'),n={name:"problems/leetcode/p1.md"};function e(h,s,p,k,r,d){return t(),a("div",null,s[0]||(s[0]=[l(`<h1 id="_1-two-sum-leetcode" tabindex="-1">1. Two Sum (LeetCode) <a class="header-anchor" href="#_1-two-sum-leetcode" aria-label="Permalink to &quot;1. Two Sum (LeetCode)&quot;">​</a></h1><p>🔗 문제 링크 → <a href="https://leetcode.com/problems/two-sum" target="_blank" rel="noreferrer">LeetCode 1. Two Sum</a></p><h2 id="문제-설명" tabindex="-1">문제 설명 <a class="header-anchor" href="#문제-설명" aria-label="Permalink to &quot;문제 설명&quot;">​</a></h2><p>주어진 정수 배열 <code>nums</code>와 정수 <code>target</code>이 있습니다. 배열 내에서 두 수를 선택하여 더했을 때, 그 합이 <code>target</code>이 되는 두 수의 인덱스를 반환하는 문제입니다. 각 입력값에 정확히 하나의 해가 존재하며, 같은 요소를 두 번 사용할 수 없습니다. 반환하는 인덱스는 순서와 상관 없습니다.</p><h3 id="입력" tabindex="-1">입력 <a class="header-anchor" href="#입력" aria-label="Permalink to &quot;입력&quot;">​</a></h3><ul><li>정수 배열 <code>nums</code>, 길이 n (2 &lt;= n &lt;= 10⁴)</li><li>정수 <code>target</code></li></ul><h3 id="출력" tabindex="-1">출력 <a class="header-anchor" href="#출력" aria-label="Permalink to &quot;출력&quot;">​</a></h3><ul><li>두 정수의 인덱스를 담은 배열</li></ul><h2 id="💡-문제-해결-전략" tabindex="-1">💡 문제 해결 전략 <a class="header-anchor" href="#💡-문제-해결-전략" aria-label="Permalink to &quot;💡 문제 해결 전략&quot;">​</a></h2><ol><li><strong>Brute Force (완전 탐색)</strong> 방법은 모든 쌍을 검사하여 <code>target</code>과 일치하는지 확인하는 방법입니다. 그러나 시간 복잡도는 O(n²)으로 비효율적입니다.</li><li><strong>해시맵 (Hash Map)</strong> 을 이용하여, 각 숫자의 인덱스를 저장하면서 현재 숫자의 보수를 빠르게 찾을 수 있습니다. 이 접근법은 O(n)의 시간 복잡도로 효율적입니다.</li></ol><p>본 풀이에서는 <strong>Hash Map을 이용한 방법</strong>을 적용합니다.</p><h2 id="typescript-풀이-코드" tabindex="-1">TypeScript 풀이 코드 <a class="header-anchor" href="#typescript-풀이-코드" aria-label="Permalink to &quot;TypeScript 풀이 코드&quot;">​</a></h2><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> twoSum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">nums</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[], </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">target</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> map</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> complement</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums[i]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (map.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">has</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(complement)) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [map.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(complement)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, i]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    map.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nums[i], i)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;No solution found&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="🛠️-코드-동작-원리" tabindex="-1">🛠️ 코드 동작 원리 <a class="header-anchor" href="#🛠️-코드-동작-원리" aria-label="Permalink to &quot;🛠️ 코드 동작 원리&quot;">​</a></h2><ol><li><strong>빈 Hash Map 생성</strong>: 숫자 값을 key, 인덱스를 value로 저장할 <code>map</code>을 초기화합니다.</li><li><strong>배열 순회</strong>: <code>nums</code> 배열을 순회하면서 다음을 수행합니다: <ul><li>현재 숫자의 보수(<code>target - nums[i]</code>)를 계산</li><li>보수가 <code>map</code>에 존재하는지 확인 <ul><li>존재하면 정답 인덱스 반환</li><li>존재하지 않으면 현재 숫자와 인덱스를 <code>map</code>에 저장</li></ul></li></ul></li><li><strong>반복 종료 후</strong>: 문제 조건상 반드시 하나의 정답이 존재하므로, 루프 내에서 반환되지 않는 경우는 없습니다. (다만, 안전성을 위해 에러 처리 추가)</li></ol><h2 id="📊-시간-복잡도와-공간-복잡도-분석" tabindex="-1">📊 시간 복잡도와 공간 복잡도 분석 <a class="header-anchor" href="#📊-시간-복잡도와-공간-복잡도-분석" aria-label="Permalink to &quot;📊 시간 복잡도와 공간 복잡도 분석&quot;">​</a></h2><table tabindex="0"><thead><tr><th>구분</th><th>복잡도</th><th>설명</th></tr></thead><tbody><tr><td>시간 복잡도</td><td>O(n)</td><td>배열을 한 번 순회하며, 각 요소에 대해 O(1) 연산 수행</td></tr><tr><td>공간 복잡도</td><td>O(n)</td><td>Hash Map에 최대 n개의 요소 저장</td></tr></tbody></table><h2 id="다른-풀이-방법과-효율성-비교" tabindex="-1">다른 풀이 방법과 효율성 비교 <a class="header-anchor" href="#다른-풀이-방법과-효율성-비교" aria-label="Permalink to &quot;다른 풀이 방법과 효율성 비교&quot;">​</a></h2><ul><li><strong>Brute Force 방법</strong>: 이중 for문으로 모든 쌍을 검사 → 시간 복잡도 O(n²), 공간 복잡도 O(1)</li><li><strong>정렬 후 투 포인터</strong>: 정렬이 필요하나, 인덱스 반환 조건 때문에 부적절 (인덱스 위치 손실됨)</li><li><strong>Hash Map 방법 (현재 방법)</strong>: O(n) 시간과 공간으로 가장 효율적</li></ul><h2 id="📝-요점-정리" tabindex="-1">📝 요점 정리 <a class="header-anchor" href="#📝-요점-정리" aria-label="Permalink to &quot;📝 요점 정리&quot;">​</a></h2><ul><li>Hash Map을 이용해 보수를 빠르게 찾는 방법이 핵심</li><li>시간 복잡도 O(n), 공간 복잡도 O(n)</li><li>정렬 방식은 인덱스가 바뀌기 때문에 부적합</li><li>가장 효율적이고 직관적인 방법은 Hash Map 활용법</li></ul>`,21)]))}const g=i(n,[["render",e]]);export{E as __pageData,g as default};
