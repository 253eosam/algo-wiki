import{_ as i,c as a,o as t,ae as e}from"./chunks/framework.ClVAdkRN.js";const E=JSON.parse('{"title":"LeetCode 122 - 주식을 사고팔기 II (Best Time to Buy and Sell Stock II)","description":"","frontmatter":{},"headers":[],"relativePath":"problems/leetcode/p122.md","filePath":"problems/leetcode/p122.md"}'),l={name:"problems/leetcode/p122.md"};function n(h,s,p,r,k,d){return t(),a("div",null,s[0]||(s[0]=[e(`<h1 id="leetcode-122-주식을-사고팔기-ii-best-time-to-buy-and-sell-stock-ii" tabindex="-1">LeetCode 122 - 주식을 사고팔기 II (Best Time to Buy and Sell Stock II) <a class="header-anchor" href="#leetcode-122-주식을-사고팔기-ii-best-time-to-buy-and-sell-stock-ii" aria-label="Permalink to &quot;LeetCode 122 - 주식을 사고팔기 II (Best Time to Buy and Sell Stock II)&quot;">​</a></h1><h2 id="문제-설명" tabindex="-1">문제 설명 <a class="header-anchor" href="#문제-설명" aria-label="Permalink to &quot;문제 설명&quot;">​</a></h2><p>정수 배열 <code>prices</code>가 주어집니다. <code>prices[i]</code>는 i번째 날의 주식 가격을 나타냅니다. 원하는 만큼 여러 번 거래(매수와 매도)를 할 수 있지만, 동시에 여러 개의 주식을 보유할 수는 없습니다. 즉, 주식을 산 후에는 반드시 팔아야만 다음 거래를 진행할 수 있습니다.</p><p>목표는 최대 이익을 얻는 것입니다.</p><hr><h2 id="최적-풀이-그리디-greedy-알고리즘" tabindex="-1">최적 풀이: 그리디(Greedy) 알고리즘 <a class="header-anchor" href="#최적-풀이-그리디-greedy-알고리즘" aria-label="Permalink to &quot;최적 풀이: 그리디(Greedy) 알고리즘&quot;">​</a></h2><h3 id="핵심-아이디어" tabindex="-1">핵심 아이디어 <a class="header-anchor" href="#핵심-아이디어" aria-label="Permalink to &quot;핵심 아이디어&quot;">​</a></h3><p>주식 가격이 전날보다 상승했다면 그 차익을 즉시 이익으로 계산하면 됩니다.</p><p><strong>이 전략이 유효한 이유는?</strong></p><ul><li>저점에서 사고 고점에서 파는 전략과, 가격이 상승하는 모든 구간의 차익을 전부 합산하는 전략은 <strong>최종적으로 동일한 수익</strong>을 주기 때문입니다.</li></ul><hr><h2 id="풀이-코드-typescript" tabindex="-1">풀이 코드 (TypeScript) <a class="header-anchor" href="#풀이-코드-typescript" aria-label="Permalink to &quot;풀이 코드 (TypeScript)&quot;">​</a></h2><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> maxProfit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">prices</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[])</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> profit </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prices.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (prices[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prices[i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      profit </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prices[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prices[i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> profit</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><hr><h2 id="동작-원리" tabindex="-1">동작 원리 <a class="header-anchor" href="#동작-원리" aria-label="Permalink to &quot;동작 원리&quot;">​</a></h2><ol><li>첫째 날부터 마지막 날까지 주식 가격 배열을 순회합니다.</li><li><strong>오늘의 가격이 어제보다 높으면</strong> 그 차액만큼 이익에 더합니다.</li><li>모든 날짜를 순회한 뒤 계산된 이익을 반환합니다.</li></ol><hr><h2 id="시간-및-공간-복잡도" tabindex="-1">시간 및 공간 복잡도 <a class="header-anchor" href="#시간-및-공간-복잡도" aria-label="Permalink to &quot;시간 및 공간 복잡도&quot;">​</a></h2><table tabindex="0"><thead><tr><th>복잡도</th><th>값</th></tr></thead><tbody><tr><td>시간 복잡도</td><td>O(n)</td></tr><tr><td>공간 복잡도</td><td>O(1)</td></tr></tbody></table><hr><h2 id="이-풀이가-가장-효율적인-이유는" tabindex="-1">이 풀이가 가장 효율적인 이유는? <a class="header-anchor" href="#이-풀이가-가장-효율적인-이유는" aria-label="Permalink to &quot;이 풀이가 가장 효율적인 이유는?&quot;">​</a></h2><ul><li>최소, 최대 가격을 따로 관리할 필요 없이 <strong>단순 비교만으로 해결 가능</strong></li><li>재귀나 동적 계획법(DP), 추가 메모리 없이도 <strong>한 번의 순회로 완료</strong></li><li>문제 조건에 가장 적합한 간단한 방법</li></ul><hr><h2 id="다른-참고-가능한-풀이-방법" tabindex="-1">다른 참고 가능한 풀이 방법 <a class="header-anchor" href="#다른-참고-가능한-풀이-방법" aria-label="Permalink to &quot;다른 참고 가능한 풀이 방법&quot;">​</a></h2><ol><li><strong>재귀 풀이</strong>: 가능한 모든 경우를 탐색 (시간 복잡도 O(2^n), 입력이 클수록 비효율적)</li><li><strong>재귀 + 메모이제이션 (Top-Down DP)</strong>: 중복 계산을 방지하여 성능 향상 (시간 복잡도 O(n²))</li><li><strong>Bottom-Up DP</strong>: 메모이제이션과 동일한 원리이나 구현이 더 복잡함</li></ol><p>하지만 <strong>이 문제에서는 그리디 알고리즘이 가장 간단하면서도 효율적입니다.</strong></p>`,26)]))}const c=i(l,[["render",n]]);export{E as __pageData,c as default};
