import{_ as e,c as t,o as i,ae as r}from"./chunks/framework.ClVAdkRN.js";const g=JSON.parse('{"title":"최소신장트리 (Minimum Spanning Tree)","description":"","frontmatter":{},"headers":[],"relativePath":"theory/algorithm/mst/index.md","filePath":"theory/algorithm/mst/index.md"}'),n={name:"theory/algorithm/mst/index.md"};function o(l,a,m,s,h,p){return i(),t("div",null,a[0]||(a[0]=[r('<h1 id="최소신장트리-minimum-spanning-tree" tabindex="-1">최소신장트리 (Minimum Spanning Tree) <a class="header-anchor" href="#최소신장트리-minimum-spanning-tree" aria-label="Permalink to &quot;최소신장트리 (Minimum Spanning Tree)&quot;">​</a></h1><h2 id="정의-🤔" tabindex="-1">정의 🤔 <a class="header-anchor" href="#정의-🤔" aria-label="Permalink to &quot;정의 🤔&quot;">​</a></h2><p>무향 가중치 그래프에서 신장 트리를 구하는 간선들의 가중치의 합이 최소인 신장 트리</p><blockquote><p>n개의 정점으로 이루어진 무향 그래프에서 n개의 정점과 n-1개의 간선으로 이루어진 트리</p></blockquote><p><img src="https://gmlwjd9405.github.io/images/algorithm-mst/spanning-tree.png" alt="그래프"></p><p>쉽게말해서 그래프에 방향이 주워지지 않고 각 선들은 비용이라는 값이 존재. 그래프의 노드들을 최소한의 비용을 이용해서 모두 연결하는 방법입니다. (최대한 쉽게 설명한거임... )</p><h2 id="문제" tabindex="-1">문제 <a class="header-anchor" href="#문제" aria-label="Permalink to &quot;문제&quot;">​</a></h2><ol><li>모든 정점을 연결하는 간선들의 가중치의 합이 최소가 되는 트리를 구하여라.</li><li>두 정점 사이의 최소 비용의 경로를 찾고 그 비용을 구하여라.</li></ol><details><summary><strong>Example</strong></summary><p><img src="https://gmlwjd9405.github.io/images/algorithm-mst/mst-example.png" alt="네트워크 연결 화면"> `Alpha`라는 동네에 모든 주민들은 인터넷을 연결할려고합니다. <p>이 인터넷은 물리적인 선을 이용하여 해당 주민들의 집을 한번씩은 연결해야 합니다.</p><p>따라서, 인터넷회사에서는 최소한의 비용을 이용해서 모든 집을 연결할려고합니다.</p><p>이때 MST 알고리즘을 이용해서 동네 주민들의 집을 모두 연결하는 최소 비용을 그래프를 만들 수 있습니다.</p></p></details><h2 id="해결-방법" tabindex="-1">해결 방법 <a class="header-anchor" href="#해결-방법" aria-label="Permalink to &quot;해결 방법&quot;">​</a></h2><ul><li><a href="https://253eosam.github.io/algo-wiki/theory/algorithm/prim.md" target="_blank" rel="noreferrer">Prim 알고리즘</a></li><li><a href="https://253eosam.github.io/algo-wiki/theory/algorithm/kruskal.md" target="_blank" rel="noreferrer">KRUSKAL 알고리즘</a></li></ul>',11)]))}const u=e(n,[["render",o]]);export{g as __pageData,u as default};
