# Two Sum (LeetCode 1)

🔗 문제 링크 → [LeetCode 1. Two Sum](https://leetcode.com/problems/two-sum/)

## 문제 설명

주어진 정수 배열 `nums`와 정수 `target`이 있습니다. 배열 내에서 서로 다른 두 원소의 합이 `target`이 되는 인덱스를 찾아야 합니다. 같은 원소를 두 번 사용할 수 없으며, 정답은 반드시 하나 존재한다고 가정합니다.

**입력:**

- 정수 배열 `nums` (길이 n, 2 <= n <= 10⁴)
- 정수 `target`

**출력:**

- 두 원소의 인덱스를 담은 배열 (순서 무관)

## 💡 문제 해결 전략

1. **브루트포스 접근:** 모든 쌍을 확인해 `target`과 같은지 비교 (O(n²))
2. **해시맵을 활용한 최적화:** 한 번의 순회로 현재 원소의 보수를 해시맵에 저장하며, 현재 원소가 해시맵에 있는지 확인 (O(n))

효율성을 위해 **해시맵을 활용한 방법**을 선택합니다.

## TypeScript 풀이

```typescript
function twoSum(nums: number[], target: number): number[] {
  const map = new Map<number, number>()

  for (let i = 0; i < nums.length; i++) {
    const complement = target - nums[i]
    if (map.has(complement)) {
      return [map.get(complement)!, i]
    }
    map.set(nums[i], i)
  }

  throw new Error('No solution found')
}
```

## 🛠️ 코드 동작 원리

1. **빈 해시맵 생성:** 숫자 값과 그에 해당하는 인덱스를 저장합니다.
2. **배열 순회:**
   - 현재 숫자의 보수(`target - 현재 숫자`)가 해시맵에 있는지 확인
   - 있다면, 보수의 인덱스와 현재 인덱스를 반환
   - 없다면, 현재 숫자와 인덱스를 해시맵에 저장
3. **반환:** 정답은 반드시 존재하므로, 정상적으로 인덱스 쌍 반환

## 📊 시간 복잡도 & 공간 복잡도 분석

| 구분        | 복잡도 |
| ----------- | ------ |
| 시간 복잡도 | O(n)   |
| 공간 복잡도 | O(n)   |

- **시간 복잡도:** 배열을 한 번만 순회하며, 해시맵의 조회 및 삽입은 O(1)
- **공간 복잡도:** 최악의 경우 해시맵에 n개의 원소가 저장됨

## 🔀 다른 풀이 방법과 효율성 비교

| 방법                    | 시간 복잡도 | 공간 복잡도 | 특징                                      |
| ----------------------- | ----------- | ----------- | ----------------------------------------- |
| 브루트포스 (이중 루프)  | O(n²)       | O(1)        | 간단하지만 비효율적                       |
| 정렬 후 투 포인터       | O(n log n)  | O(1)        | 인덱스가 필요한 경우 부적합 (인덱스 손실) |
| 해시맵 사용 (현재 방법) | O(n)        | O(n)        | 최적, 한 번의 순회로 해결 가능            |

## 📝 요점 정리

- 해시맵을 활용하면 O(n) 시간 복잡도로 문제를 효율적으로 해결 가능
- 인덱스를 유지하면서 빠른 조회가 필요한 문제에 적합
- 다른 방법에 비해 직관적이고 구현이 간단하며 가장 효율적
